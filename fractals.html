<!DOCTYPE html>

<html lang="en">

<head>
<meta charset="utf-8">
<title>Fractals Reimagined</title>
</head>

<body>
<h1>
Fractals Reimagined!
</h1>

<p>This is the basic koch curve below: <code>modified_koch(t, 4, 3)</code></p>

<img src="koch_orignal.png">

<p>This reimagining of the koch curve. In this case, at each depth, the length of the koch "line" is multipled by a random factor of 1 or 2. Furthermore, the pen color of the turtle becomes blue once depth increases beyond 1. This creates a slightly more unique pattern while still retaining the overall shape.</p>
<pre><code>
def modified_koch(t, depth, length):
    t.pd()
    length = length * random.randrange(1, 2)
    if depth == 1:
        t.fd(length * 2)
    if depth > 0:
        t.pencolor("blue")
        modified_koch(t, depth - 1, length)
        t.lt(60)
        modified_koch(t, depth - 1, length)
        t.rt(120)
        modified_koch(t, depth - 1, length)
        t.lt(60)
        modified_koch(t, depth - 1, length)
</code></pre>
<img src="koch_modified.png">

<p>--------------------------------------------------------------------------------------------------------</p>

<p>This is the initial sierpenski triangle: <code>sierpinski(t, 5, 200)</code></p>

<img src="sierpenski_original.png">

<p>This is a reimagining of the sierpenski triangle, with the following modifications:
<ol>
<li>The color of the turtle's pen has been changed to brown once the depth increased beyond 1.</li>
<li>As the turtle put the pen up each time when it is drawing the third case of the sierpenski triangle.</li>
<li>The turtle puts the pen back down each time the third case is done.</li>
</ol>
This creates an interestingly non-symmetric design that resembles a video game level.
</p>
<pre><code>
def mod_sier(t, depth, size, scale_factor=1):
    if depth == 1:
        triangle(t, size)
    else:
        t.pencolor("gray")
        mod_sier(t, depth-1, size/2)
        t.fd(size/2)
        mod_sier(t, depth-1, size/2)
        t.bk(size/2)
        t.lt(60)
        t.fd(size/2)
        t.rt(60)
        t.pu()
        mod_sier(t, depth-1, size/2)
        t.rt(120)
        t.fd(size/2)
        t.lt(120)
        t.pd()
</code></pre>
<img src="sier_modified.png">

<p>--------------------------------------------------------------------------------------------------------</p>

<p>This is a bland tree: <code>tree(t, 6, 100, 10)</code></p>
<img src="tree.png">

<p>Following a reimagining, the following changes have been made:
<ol>
<li>The color of the tree is now brown.</li>
<li>The width steadily decreases by a factor of 0.9 everytime you move up a depth.</li>
<li>A random number between 0 and 5 is added to the length of each line/branch, allowing for more diversified branch lengths.</li>
</ol>
Overall, this creates a more realistic resemblance of a tree.
</p>
<pre><code>
def slanted_tree(t, depth, length, angle, width):
    t.color("brown")
    t.width(width)
    if depth == 1:
        t.fd(length)
        t.bk(length)
    else:
        a = angle + random.randrange(1, 2)
        l = length + random.randrange(0, 5)
        t.fd(length)
        t.rt(angle)
        slanted_tree(t, depth-1, l, a, width * 0.85)
        t.lt(angle * 2)
        slanted_tree(t, depth-1, l, a, width * 0.85)
        t.rt(angle)
        t.bk(length)
</code></pre>
<img src="new_tree.png">

</body>

</html>
